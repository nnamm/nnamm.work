[{"content":"アクセス解析サービス\u003e アクセス解析サービス 当サイトでは、Google の提供するアクセス解析サービス「Google アナリティクス」を使用しています。トラフィックデータを収集するために、Google がお使いのブラウザの Cookie を設定したり、既存の Cookie を読み取ることがあります。このデータは匿名で収集されており、個人を特定するものではございません。\n収集された情報は、当サイトのパフォーマンスやコンテンツを改善する目的に利用する場合がございます。\nGoogle アナリティクスのデータ収集、処理の仕組みについては、「 Google のサービスを使用するサイトやアプリから収集した情報の Google による使用 – ポリシーと規約 – Google」のページを参照下さい。\nこうした Cookie による情報収集を望まない場合は、ユーザ自身がブラウザで Cookie の受け入れを拒否するよう設定することも可能です。一例として「 Google アナリティクス オプトアウト アドオン」がございます。\n著作権\u003e 著作権 nnamm.work における各種コンテンツの著作権は放棄しておりませんが、当サイト記事の引用や、紹介についてはご自由になさっていただいて構いません。シェアは大歓迎です。引用する際は、よかったら Facebook か Twitter からご連絡をいただければ幸いです。\n作成：2021 年 5 月 29\n","date":"2021/05/29","permalink":"/privacy-policy/","section":"","summary":"nnamm.workのプライバシーポリシー","title":"Privacy Policy"},{"content":"","date":"2020/05/18","permalink":"/","section":"","summary":"","title":""},{"content":"","date":"2020/05/18","permalink":"/blog/","section":"","summary":"","title":""},{"content":"","date":"2020/05/18","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"2020/05/18","permalink":"/tags/jetbrains/","section":"Tags","summary":"","title":"JetBrains"},{"content":"","date":"2020/05/18","permalink":"/categories/programming/","section":"Categories","summary":"","title":"Programming"},{"content":"","date":"2020/05/18","permalink":"/tags/pycharm/","section":"Tags","summary":"","title":"PyCharm"},{"content":"","date":"2020/05/18","permalink":"/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"PyCharm できれいなコードを書くために以下の設定をしました。\nBlack flake8 isort mypy Pylint PyCharm は標準設定でもコードチェックや整形をやってくれます。それに加え、各種ツールを活用して Python のコーディング規約にそった開発をしていくことが望ましいです。\n本記事では PyCharm にファイル監視機能をつけて、保存のたびにフォーマッターなどを機能させる設定方法をまとめます。\n【更新履歴】\n23.1.7 ｜ Hugo 化に伴い記事全文を整形。注）2023 年のいわゆるモダンな情報ではありませんがまだ有用な内容と思います。\n20.6.28 ｜ isort の設定を変更。multi_line_output に関する設定を削除。import を 1 行表示とするために force_single_line=true を追加。\n20.5.27 ｜ isort を追加。flake8 の設定を変更（1 行の文字数を 120 → 88）。\n20.5.21 ｜ flake8 などの設定を見直し\n20.5.18 ｜公開\nFile Watchers プラグイン（ファイル監視機能）\u003e File Watchers プラグイン（ファイル監視機能） まずファイルを監視してくれるプラグインを導入します。\nPreferences → Plugins → file watchers と検索して Go!!\nインストールすると、File Watchers の項目が追加されます。ここに各種ツールの設定を書きます。\nBlack（コードフォーマッター）\u003e Black（コードフォーマッター） Black は Python3.6 以上で使える超強力なコードフォーマッターです。PEP8 に準拠しているのはもちろん、より制限のきつい PEP8 と言われている存在。ユーザーからはほとんど設定変更ができないガッチガチ仕様。\n▶︎ Black documentation\n記事投稿時点ではベータ版なので、今後仕様変更される可能性はあります。\n設定\u003e 設定 Black の設定は pyproject.toml を使用します。プロジェクト直下に生成し、1 行の文字数を 88（Black デフォルト）にしました。\n[tool.black] line-length = 88 PyCharm の File Watchers は以下のようにします。\n項目 設定値 Name Black（任意名） File type Python Scope Current Fles or Project Files など Program $PyInterpreterDirectory$/black Arguments $FilePath$ Output paths to refresh $FilePath$ Working directory $ProjectFileDir$ Auto-save edited files to trigger the watcher off Trigger the watcher on external changes off black --help やリファレンスを見ながら設定しました。\n「Tool to Run on Changes」は CUI でコマンド入力する状態を GUI から設定できるってイメージ。Black は標準で pyproject.toml を読み込むので、引数は Python のファイルパスだけです。\n$xxxxxxxxxx$について\u003e $xxxxxxxxxx$について プロジェクトディレクトリなどを表すショートカットです。「Tool to Run on Changes」の各欄の「+」をクリックすると選択できます。\nflake8（静的文法チェックツール）\u003e flake8（静的文法チェックツール） flake8 は静的な文法チェックツール。以下をラッパーしており、使っていない変数のチェックなど「これおかしいよー」という箇所を検出してくれます。\nPyFlakes pycodestyle Ned Batchelder’s McCabe script 設定\u003e 設定 設定ファイルは一元管理したいので pyproject.toml に書きます。1 行の文字数を Black に合わせたり、循環的複雑度を設定しました。\n[flake8] max-line-length = 88 max-complexity = 20 項目 設定値 Name flake8（任意名） File type Python Scope Current Fles or Project Files など Program $PyInterpreterDirectory$/flake8 Arguments \u0026ndash;statistics \u0026ndash;config $ContentRoot$/pyproject.toml \u0026ndash;ignore E203,W503,W504 $FilePath$ Output paths to refresh $FilePath$ Working directory $ProjectFileDir$ Auto-save edited files to trigger the watcher off Trigger the watcher on external changes off flake8 --help やリファレンスを見ながら設定しました。\nignore の指定について\u003e ignore の指定について flake8 で特定の警告やエラーを無効にしたい場合は toml ファイルにこう書きます。\nignore = \u0026lsquo;E203\u0026rsquo;, \u0026lsquo;W503\u0026rsquo;, \u0026lsquo;W504\u0026rsquo;\n（Black との衝突を防ぐコード）\nしかし、なぜか PyCharm ではエラーとなります。toml にエラーがあると他のチェッカーが誤動作しますので、回避策として File Watchers で「\u0026ndash;ignore」指定することにしました。（テーブルの設定値参照）\nisort（コードフォーマッター）\u003e isort（コードフォーマッター） isort は import/from 部分を PEP8 に準じてソートしてくれるフォーマッターです。Black はそこまで整形してくれないんですよね。\n設定\u003e 設定 こちらも pyproject.toml に書きます。Black との衝突を防ぐために文字数を合わせます。 multi_line_output には複数行になる場合のソート方法を指定します。\n[tool.isort] line_length = 88 force_single_line = true 項目 設定値 Name isort（任意名） File type Python Scope Current Fles or Project Files など Program $PyInterpreterDirectory$/isort Arguments $FilePath$ Output paths to refresh $FilePath$ Working directory $ProjectFileDir$ Auto-save edited files to trigger the watcher off Trigger the watcher on external changes off isort --help でいろいろ確認できます。\n導入時の注意点\u003e 導入時の注意点 isort を普通にインストールすると ~/.isort.cfg を参照します。pyproject.toml で一元管理するためには pip install 'isort[pyproject]' とするか、PyCharm からなら Options に pyporject を指定すれば OK です。\nmypy（静的型ヒントチェッカー）\u003e mypy（静的型ヒントチェッカー） mypy は静的な型ヒントチェッカーです。flake8 と同じようなもので「適切に型ヒントかけているかな？」という観点でみてくれます。\n設定\u003e 設定 こちらも pyproject.toml に書きます。\n[mypy] ignore_missing_imports = 1 項目 設定値 Name mypy（任意名） File type Python Scope Current Fles or Project Files など Program $PyInterpreterDirectory$/mypy Arguments \u0026ndash;config-file $ContentRoot$/pyproject.toml $FilePath$ Output paths to refresh $FilePath$ Working directory $ProjectFileDir$ Auto-save edited files to trigger the watcher off Trigger the watcher on external changes off mypy --help でいろいろ確認できます。\nPylint（静的文法チェックツール）\u003e Pylint（静的文法チェックツール） Pylint は静的な文法チェックツールです。flake8 と重複する部分もあるでしょうけど、両方採用して厳しめにチェックしてもいいでしょう。たとえば、flake8 と Pylint で引っ掛かったら、絶対に直すべきポイントだと思います。\n設定\u003e 設定 Pylint も　pyproject.toml　に設定できますが、.pylintrcに書くことにしました。pylint --generate-rcfile　するとたくさんの標準設定があり、それらを有効にしておいた方が良いと考えたためです。\nただ、このままだと多くの変数にたいして「大文字にせぃ」とのたまってきます。変数は小文字が普通だと思うのですが（ですよね？）\nというわけで「名前について文句ゆーな」という設定や Black との衝突を防ぐなどの設定を .pylintrc に書き込みます。\n// 設定ファイル生成 $ pylint --generate-rcfile \u0026gt; .pylintrc $ vim .pylintrc // [MESSAGES CONTROL]セクションの”disable=”に以下を追記 + invalid-name + bad-continuation // [FORMAT]セクションで1行当たりの文字数を他と揃える - max-line-length=100 + max-line-length=88 // [DESIGN]セクションで最低バブリックメソッド数を変更（必要に応じて） - min-public-methods=2 + min-public-methods=0 or 1 項目 設定値 Name pylint（任意名） File type Python Scope Current Fles or Project Files など Program $PyInterpreterDirectory$/pylint Arguments \u0026ndash;rcfile $ContentRoot$/.pylintrc $FilePath$ Output paths to refresh $FilePath$ Working directory $ProjectFileDir$ Auto-save edited files to trigger the watcher off Trigger the watcher on external changes off Pylint は基本的に無効\u003e Pylint は基本的に無効 僕の環境では Pylint 処理にほんちょっと時間がかかります。保存のたびに「このちょっと」が気になるので、Pylint の自動処理を無効としておき、折を見て有効にしています。\n有効・無効は File Watchers 設定画面のチェックボックス ON/OFF でできます。\nしばらく使ってみたところ、ちょっとした時間はとくに気にならないため常に有効としました。（2020.5.21）\n設定ファイルはエクスポートしておくと楽\u003e 設定ファイルはエクスポートしておくと楽 これまで設定したものを他のプロジェクトに流用できるよう、設定ファイルのインポート／エクスポート機能があります。\nFile Watchers 設定画面の下部にある矢印アイコンがそれ。右上矢印がエクスポート、左下矢印がインポート。\npyproject.toml や .pylintrc も一緒に保存しておくと非常に楽ですよ。\nおわりに\u003e おわりに Python の良い点に「コードの読みやすさ」があります。でも、PEP8 などのルールを無視して書いていたらその良さは活かせません。だから、この手のことは IT の力に任せちゃいましょう。\n今回は PyCharm で設定しましたけど、Visual Studio Code や Vim でも同様の設定はできるので、自分の好きなエディタで開発を楽しんでいけばいいと思います。\n参考にさせていただいた記事\u003e 参考にさせていただいた記事 Python 開発を円滑に進めるためのツール設定 Part.1 - ログミー Tech ことの発端となった記事です。実務はこうなのか〜と知って「じゃあ、僕もやってみよう」となったのでした。\nそのほかの参考記事はこちら。\nblack と pylint を使った快適な Python 開発 - Qiita もう Python の細かい書き方で議論しない。black で自動フォーマットしよう - Make 組ブログ ","date":"2020/05/18","permalink":"/blog/004-write-cleancode-with-pycharm/","section":"","summary":"Black/flake8/isort/mypy/pylint の設定例方法","title":"Python｜きれいなコードを書くための PyCharm 設定メモ"},{"content":"","date":"2020/05/18","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"これまで Python スクリプトを組んできたものの、いずれもユニットテストは未実施。自分仕様ですから「そこまでしなくても」となりがち。でも、実際の現場ではテストは必須。潜在的なバグに気づけますから。\n実は昨今のテストって仕組みがややこしそう（※）・・・と敬遠してましたが、それではいつまで経ってもレベルアップできませんのでユニットテストにチャレンジしました。\n※人生ではじめて単体テストしたのは某鶴のマークの航空会社のアセンブリ言語でした。機械語の細かい挙動を見ながらやっていましたね。それはもう地味で地道な作業でしたが必要なことでした。・・・とこのような経験からいわゆる高級言語のテストがどうやって動いているのかイメージができいないんです。\n※しかし、2023 年 1 月現在は Golang の testing を学んだりして、昨今のテストは昔に比べてなんて楽なんだと感じています。テストコードを書くのは手間ですけどね（笑）\n環境\u003e 環境 Python 3.8.2 テストフレームワーク： unittest テスト対象： md-generator 参考： Python と Automator でブログ執筆ツールをつくりました テストの準備\u003e テストの準備 テストファイルの作成\u003e テストファイルの作成 まずはテストファイルを作ります。「test_ + テスト対象モジュール名.py」とするのが習わしなので、「test_gen_md_generator.py」となります。\nコードはこんな感じになりました。\n# test_gen_md_generator.py \u0026#34;\u0026#34;\u0026#34; md-generator のユニットテストケース \u0026#34;\u0026#34;\u0026#34; import os import unittest import gen_md_file as md TEST_ANS_DICT = { \u0026#34;new_dir_name\u0026#34;: \u0026#34;006\u0026#34;, \u0026#34;new_dir_path\u0026#34;: \u0026#34;/Users/nnamm.work/Develop/MyProject/_test/006\u0026#34;, \u0026#34;created_date_long\u0026#34;: \u0026#34;2020-04-29 15:00:00\u0026#34;, \u0026#34;created_date_short\u0026#34;: \u0026#34;200429\u0026#34;, \u0026#34;eye_path\u0026#34;: \u0026#34;/ec/blog/ec_blog_006.jpg\u0026#34;, \u0026#34;slug_str\u0026#34;: \u0026#34;006-200429-\u0026#34;, \u0026#34;post_type\u0026#34;: \u0026#34;blog\u0026#34;, } TEST_ANS_LIST = [\u0026#34;006_200429.md\u0026#34;, \u0026#34;img\u0026#34;] class GeneratorMdTest(unittest.TestCase): \u0026#34;\u0026#34;\u0026#34; テストクラス \u0026#34;\u0026#34;\u0026#34; def setUp(self) -\u0026gt; None: pass def tearDown(self) -\u0026gt; None: pass def test_create_front_matter_info(self): \u0026#34;\u0026#34;\u0026#34; フロントマター情報の確認 \u0026#34;\u0026#34;\u0026#34; self.assertDictEqual( md.create_front_matter_info(\u0026#34;/Users/nnamm.work/Develop/MyProject/_test/\u0026#34;), TEST_ANS_DICT, ) def test_generate_blog_file(self): \u0026#34;\u0026#34;\u0026#34; ディレクトリとファイル生成の確認 \u0026#34;\u0026#34;\u0026#34; # まずディレクトリとファイルを作成 md.generate_blog_file(TEST_ANS_DICT) # ディレクトリとファイルが正しく作成されているか確認（詳細な中身は目視確認とする） path = \u0026#34;/Users/nnamm/Develop/MyProject/_test/006/\u0026#34; files_list = os.listdir(path) files_list.sort() self.assertListEqual(files_list, TEST_ANS_LIST) テストコードの説明\u003e テストコードの説明 import\n「unittest」と「テスト対象とモジュール」をインポートして、クラスの中に「def test_XXXXXX」でテストケースを作っていきます。\nTEST_ANS_DICT / TEST_ANS_LIST\nassert で評価される値です。テストケースに定数を書いて良いものか標準的なルールを知らないため、そこらへんはご容赦を。\nsetUp() / tearDown()\n各テストの実施前後にさせたい処理を書きます。たとえば print(\u0026quot;Test Start\u0026quot;)、print(\u0026quot;Test End\u0026quot;) としてコンソールログを見やすくしたり、オブジェクトを破棄したりのお掃除系。\ndef test_create_front_matter_info(self)\nFront matter を生成する処理で dict が返ります。テスト用のディレクトリを準備し、想定される結果（TEST_ANS_DICT）と assertDictEqual しています。\ndef test_generate_blog_file(self)\nFront matter を含めた md ファイルを生成する処理です。とくに return されるものはなく、ディレクトリとファイルが生成されます。\n確認ポイント\u003e 確認ポイント さて、ここでは何を確認するべきか？\n想定されたディレクトリ・ファイル構造になったかどうかを評価することにしました。そのために os.listdir() したものを assertListEqual しています。\n実際のファイルは開いて中身を目視確認すればいいでしょう。（下図参照）\nテストの実行\u003e テストの実行 テストコードを PyCharm で走らせてみます。\nEdit Configurations\u003e Edit Configurations Edit Configurations から設定します。\nAdd New Configuration から unittests を選択したら、適当な Name をつけて対象スクリプトを選択して OK します。\nRun\u003e Run うまくいけば「Tests passed」が表示されます。\nassert で想定した結果にならなかった場合、どこが間違っているか表示されるので修整もやりやすかったです。\nやって良かったこと\u003e やって良かったこと 潜在的なバグを見つけたことですね。\n具体的には「create_front_matter_info」で「Python list index out of range」が起こる可能性があります。\nこの関数にはリストから最後の要素を取り出す処理があります。でも、そもそもリストがなければエラーとなります。僕の環境では起こらないので対処しなくてもいいけれど、せっかくなので該当箇所に try 〜 catch をいれました。\n改修した満足感 Get です（笑）\n# gen_md_generator.py（対応前） p = pathlib.Path(work_dir) dir_list = [p.name for p in p.iterdir() if p.is_dir()] dir_list.sort() latest_dir = int(dir_list[-1]) ← ★ここ fm_dict[\u0026#34;new_dir_name\u0026#34;] = str(latest_dir + 1).zfill(3) fm_dict[\u0026#34;new_dir_path\u0026#34;] = work_dir + fm_dict[\u0026#34;new_dir_name\u0026#34;] # gen_md_generator.py（対応後） p = pathlib.Path(work_dir) dir_list = [p.name for p in p.iterdir() if p.is_dir()] dir_list.sort() try: latest_dir = int(dir_list[-1]) fm_dict[\u0026#34;new_dir_name\u0026#34;] = str(latest_dir + 1).zfill(3) fm_dict[\u0026#34;new_dir_path\u0026#34;] = work_dir + fm_dict[\u0026#34;new_dir_name\u0026#34;] except IndexError as err: print(f\u0026#34;作成できません。対象ディレクトリを確認してください。：{err}\u0026#34;) 不明点\u003e 不明点 datetime で now() を使って現在日時を取得している値の正確性を得るためには、テストケースとしてどうすれば良いかわかりませんでした。普通であれば絶対にイコールになることはないですから。\nしゃーないので、テストのときだけテスト対象のモジュールに任意の日時を指定するロジックを加えて回避しました。\n# gen_md_generator.py # 新記事の作成日時（long: YYYY-MM-DD HH:MM:SS / short: YYMMDD） dt = datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) # dt = datetime.datetime(2020, 4, 29, 15).strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) # unittest用に日時指定 ↑★ここ、テスト時だけコメントアウトする ※おそらく unittest.mock を使うのかも。今回は調査していませんので次の課題です。\nおわりに\u003e おわりに 初歩の初歩とはいえユニットテストをやり切りました！\n今回得たことは「テストしやすいコードはどうすれば組めるか？」という視点ですね。複雑な処理を重ねてやることもあるでしょうけど、ややこしい処理は分解してシンプルに組めばテストしやすくなるはず。\nテストしやすいということは、コード品質を上げやすいということ。\nだからといって、やたらと分解していいものでもないと思いますので、その塩梅は開発を経験し、センスが磨かれていくことで掴めていくものでしょう。センスはやればやるほど自然と磨かれているものだからね。\nユニットテスト、いい経験と気づきになりました。\n※掲載した写真は大阪城公園を RICOH GR で撮影\n","date":"2020/04/29","permalink":"/blog/003-python-first-unittest/","section":"","summary":"unittest を使った感想","title":"Python｜はじめての unittest、使い方を整理してみる"},{"content":"","date":"2020/04/05","permalink":"/tags/macos/","section":"Tags","summary":"","title":"macOS"},{"content":"静的サイトジェネレーターは静的ファイルを生成します。WordPress とは異なり、記事公開まで数ステップ必要です。\n記事を書く ビルドして全サイトデータを生成（※） レンタルサーバーにすべてのファイルをアップロード だから、GitHub pages を使っている方もいらっしゃると思います。git push とともにデプロイされるのは楽ですからね。 Vercel を使うのもありでしょう。\nでも、僕はすでに持っている独自ドメインや WordPress で使っているレンタルサーバーがあるのでこれらを流用したい。\nそこで公開までさくっとやってくれるスクリプトを組みました。Pyftpsync を使い、 前回と同じく Automator を使ってアプリケーション化しています。\nPyftpsync とは\u003e Pyftpsync とは Martin Wendt さんがつくられている Python ライブラリで「ローカルとリモートを rsync 風にやってくれるもの」と僕は理解しています。\n▶︎ Pyftpsync\nただし、既知の制限があります。最たるものは 2 つ。\n差分検知はファイルサイズと変更日から判断している ローカルフォルダ内に個別のメタデータファイルをつくり、最後の同期時刻とサイズを保存することで差分を検出する つまり Gridsome ではこうなります。\nstatic 配下の画像ファイルなど同一同名でも「差分あり」となる ビルドすると dist 配下のすべてのファイルが全削除＆再生成されるため、上記 2 の効果がない 結果、ほとんどのファイルがアップロード対象となる 当初の僕の希望である「rsync コマンドのように差分だけがアップロードされればデプロイも短時間で済むじゃん」は達成できません。\nでもメリットもちゃんとあります。手動でアップロードするよりだんぜん楽ということです。\n2023 年 1 月現在、SSG を Gridsome から Pelican に、さらに Hugo に移行しました。Gridsome の記述がありますが、Hugo で使っていません。本記事では Pyftpsync の使い方の紹介なので当日の記事のままとします。\nPyftpsync の使い方\u003e Pyftpsync の使い方 公式のとおりに作ればとてもカンタン。使いやすい設計です。以下は同期モードの例で、他にアップロードモードがあります。\nfrom ftpsync.ftp_target import FtpTarget from ftpsync.targets import FsTarget from ftpsync.synchronizers import BiDirSynchronizer local = FsTarget(\u0026#34;ローカルディレクトリパス\u0026#34;) remote = FtpTarget( \u0026#34;リモートディレクトリパス\u0026#34;, \u0026#34;FTPサーバーアドレス\u0026#34;, username=\u0026#34;FTPアカウント\u0026#34;, password=\u0026#34;FTPパスワード\u0026#34;, tls=True # Trueの場合、FTPSが有効 ) # オプション設定例 opts = { \u0026#34;resolve\u0026#34;: \u0026#34;local\u0026#34; # コンフリクトした場合はローカルファイルを優先 } # 同期の実行 sync = BiDirSynchronizer(local, remote, opts) sync.run() ※デフォルトではコンソールにログ出力されますので何やっているかが分かります。\nおわりに\u003e おわりに WordPress や note を使ってきて「公開までの仕組みがすべてつくられていること」ってすごいことだなと痛感しています。で、ここにきて SSG を使ったサイト運営ですよ。\n「手間かかることを楽しんでいる」感があります（笑）\nでも、その結果\n楽するためにどうするか？ 効率化するためできることはあるか？ という視点が磨かれてきましたし、なければつくってしまえ、という思考＆行動パターンになってきました。エンジニアに復帰した僕としては、これはとても望ましい成長と思っています。\nひとつひとつ作っていく感覚は楽しいです。\n最近はコロナのせいで自宅に籠る時間ができました。だからこそ、思いっきり勉強したり、思いっきり怠惰をむさぼったり、これまでの生活スタイルを進化させられるんじゃないか、と僕は思います。\nたとえば、当たり前と言われているものの反対をやってみて、人間としての幅を広げられたらいいんじゃないかな。\n「より良い未来のために、今できることをする」です。\n参考：sync_gridsome.py\u003e 参考：sync_gridsome.py \u0026#34;\u0026#34;\u0026#34; pyftpsyncライブラリを同期モードで使用し、Gridsomeでビルドしたデータ（dist/）をデプロイ先と同期する \u0026#34;\u0026#34;\u0026#34; import configparser import logging.handlers from ftpsync.ftp_target import FtpTarget from ftpsync.targets import FsTarget from ftpsync.synchronizers import BiDirSynchronizer from ftpsync.util import set_pyftpsync_logger def sync_gridsome() -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; 指定のローカルとリモートディレクトリを同期する \u0026#34;\u0026#34;\u0026#34; cfg = configparser.ConfigParser() cfg.read(\u0026#34;config.ini\u0026#34;) # ローカルとリモートの設定 local = FsTarget(cfg[\u0026#34;PATH\u0026#34;][\u0026#34;LOCAL\u0026#34;]) user = cfg[\u0026#34;FTPS\u0026#34;][\u0026#34;USER\u0026#34;] passwd = cfg[\u0026#34;FTPS\u0026#34;][\u0026#34;PASSWORD\u0026#34;] remote = FtpTarget( cfg[\u0026#34;PATH\u0026#34;][\u0026#34;REMOTE\u0026#34;], # リモートディレクトリパス cfg[\u0026#34;FTPS\u0026#34;][\u0026#34;SERVER\u0026#34;], # FTPサーバ username=user, password=passwd, tls=True, # FTPS有効 ) # オプション設定 # ローカル優先／--deleteオプション有効／指定ディレクトリは同期除外 # opts = {\u0026#34;resolve\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;delete\u0026#34;: True, \u0026#34;force\u0026#34;: True} opts = {\u0026#34;resolve\u0026#34;: \u0026#34;local\u0026#34;} # 同期の実行 sync = BiDirSynchronizer(local, remote, opts) sync.run() if __name__ == \u0026#34;__main__\u0026#34;: # ロガーの設定 # pyftpsync.logにログを残す logger = logging.getLogger(\u0026#34;sync.gridsome\u0026#34;) log_path = \u0026#34;./pyftpsync.log\u0026#34; handler = logging.handlers.WatchedFileHandler(log_path) formatter = logging.Formatter( \u0026#34;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#34; ) handler.setFormatter(formatter) logger.addHandler(handler) set_pyftpsync_logger(logger) # 同期 sync_gridsome() ▶ 最新版は GitHub\n","date":"2020/04/05","permalink":"/blog/002-python-ftp-sync/","section":"","summary":"Pyftpsync の使用方法","title":"Python｜Pyftpsync を使ってローカルとリモートを同期する"},{"content":"","date":"2020/03/29","permalink":"/categories/creative/","section":"Categories","summary":"","title":"Creative"},{"content":"静的サイトジェネレーター（SSG）で作ったサイトの記事は Markdown ファイルで管理します。\nWordPress でいう Title、Date、Description、Category、tags などの設定もできて、ファイルの冒頭に Front matter と呼ばれるデータを書きこむことで、SSG がよしなに判断してあれこれしてくれます。\nただ、記事を書くたびに\nファイルを作成 Front matter（定型文）をコピペ タイトルや日付などを入力 するのは手間がかかるので macOS の Automator を使ってツールを 2 つ作りました。\nMarkdown ファイルを作り、任意のエディタを起動するアプリ gridsome develop を起動し、指定のブラウザで localhost に接続するショートカットキー この記事では Python や Automator との連携方法をまとめます。\n2021 年 6 月現在、SSG を Gridsome から Pelican に変更しました。Front matter の中身も変わったため、掲載している内容やスクリプトが現在とは若干異なっています。でも、本筋は変わっていませんので参考になるかと思います。\n1. Markdown ファイルを作り、任意のエディタを起動するアプリ\u003e 1. Markdown ファイルを作り、任意のエディタを起動するアプリ Python で Markdown ファイルを作る\u003e Python で Markdown ファイルを作る 僕のサイトでは以下のように記事ファイルと画像ファイルを配置しています。\n/static/posts/blog/ | |__001/ | |__img/ | |__001_200322.md | |__002 | |__img/ | |__002_YYMMDD.md | （以降、003、004と記事ごとに増えていく） 「ディレクトリ名が 1 つずつ加算されている」部分やファイル名の「YYMMDD」などがプログラミングの使い所。\nディレクトリやファイル操作をすればいいので Pathlib モジュールを使います。パスをオブジェクトとして操作できるようになります。\n参考： pathlib \u0026mdash; オブジェクト指向のファイルシステムパス\n次は Front matter です。\nこれは以下のようなデータ群になってます。「$」ではじまっている変数はスクリプトを実行するたびに設定します。これを毎回コピペするのはすっごく面倒なのでここでもプログラミングの力を使いましょう。\n--- title: date: $date createdAt: $date updatedAt: $date description: image: $image slug: $slug category: tags: type: $type --- 「$」は定型文や動的にテキストデータを設定するところなので、String モジュールのtemplateを使います。\n参考： string \u0026mdash; 一般的な文字列操作\n使い方はかんたんで、Front matter の定義ファイルを開いて、substitute()で$変数に値を入れる。それを Markdown ファイルにwrite()で OK です。\n# gen_md_file.py（一部抜粋） import string md_full_path = f\u0026#34;{dir_path}/{dir_name}_{s_date}.md\u0026#34; with open(\u0026#34;template/front_matter.txt\u0026#34;) as fm: t = string.Template(fm.read()) template = t.substitute(date=l_date, image=img_path, slug=slug, type=post_type) with open(md_full_path, \u0026#34;w\u0026#34;) as new_md: new_md.write(template) Automator からスクリプトを実行してエディタを起動する\u003e Automator からスクリプトを実行してエディタを起動する 新しく記事を書くたびに python コマンドを叩くのは手間です。それにどうせなら Markdown ファイルを開いてすぐブログを書きはじめられたら素敵じゃないですか。\nそんなときは Automator にシェルコマンドを入力してもらいましょう。\nAutomator を起動して「アプリケーション」を選択。\nAutomator で Python を実行するには、シェルから実行してもらうようにしないといけません。以下の順番でつなげていきます。\nシェルスクリプトを実行 指定された Finder 項目を取得 Finder 項目を開く（お好きなアプリを選択） シェル実行時に Markdown ファイルの絶対パスをprint()で出力しています。それが「指定された Finder 項目を取得」につながって、次の「Finder 項目を開く」へとつながっていきます。\nさらに、どうせなら Automator で作ったアプリのアイコンも変えましょう。\nまず、Automator で作たアプリの情報ウィンドウを表示させます。次に左上のアイコンを選択状態にしてから、あらかじめクリップボードにコピーしておいた画像を command+v してあげれば OK です。\n2. gridsome develop を起動し、指定のブラウザで localhost に接続するショートカットキー\u003e 2. gridsome develop を起動し、指定のブラウザで localhost に接続するショートカットキー 記事を書きながらプレビューできたら便利ですよね。今回はショートカットキーで起動するようにします。\nAutomator を起動して「クイックアクション」を選択。\n以下の順でつなげていきます。\n指定された Finder 項目を取得（後述のコマンドファイルを指定） Finder 項目を開く 一時停止（ビルドにちょっと時間がかかるため一休み） シェルスクリプトを実行（ブラウザのフルパス + URL） コマンドファイル\u003e コマンドファイル 「シェルスクリプトを実行」から直接gridsome developをすると、ctrl+c で Gridsome のプロセスを停止できません。僕から見えない誰かがプロセスを握ってしまっているためだと思います。\nなので、以下のコマンドファイルを作り、Terminal を起動してから実行してあげる必要があります。\n$ touch _start_gridsome.command $ vim _start_gridsome.command cd ~/Develop/MyProject/gridsome_nnamm/ gridsome develop 実行権限をつけるのを忘れずに。\n$ chmod a+x _start_gridsome.command ショートカットキーの設定\u003e ショートカットキーの設定 クイックアクションは macOS のサービスとして扱われるため、システム環境設定から任意のショートカットキーを割り当ててあげましょう。\nこれで完成です。\nおわりに\u003e おわりに アプリアイコンをダブルクリックするだけでブログが書けるようになりました。必要に応じてショートカットキーでプレビュー画面を起動するということもできました。\n大満足！\n参考：gen_md_file.py\u003e 参考：gen_md_file.py \u0026#34;\u0026#34;\u0026#34; 新規ブログ記事の雛形Markdownファイルを作るスクリプト 所定のディレクトリに、以下のディレクトリを作成する ...blog/ |__001 |_img/ |_001_YYMMDD.md（フロントマター含） \u0026#34;\u0026#34;\u0026#34; import configparser import datetime import pathlib import string def create_front_matter_info(work_dir: str) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34; フロントマター用のデータを作成する Args: work_dir: 所定のディレクトリパス Returns: dict: フロントマターに設定する情報 \u0026#34;\u0026#34;\u0026#34; fm_dict = { \u0026#34;new_dir_name\u0026#34;: \u0026#34;\u0026#34;, # 新記事を格納するディレクトリ名（作業用） \u0026#34;new_dir_path\u0026#34;: \u0026#34;\u0026#34;, # 上記を含めたフルパス \u0026#34;created_date_long\u0026#34;: \u0026#34;\u0026#34;, # 記事作成日時ロング版（スクリプト実行日時） \u0026#34;created_date_short\u0026#34;: \u0026#34;\u0026#34;, # 上記のショート版 \u0026#34;eye_path\u0026#34;: \u0026#34;\u0026#34;, # アイキャッチの画像のパス \u0026#34;slug_str\u0026#34;: \u0026#34;\u0026#34;, # スラッグ \u0026#34;post_type\u0026#34;: \u0026#34;blog\u0026#34;, # ポストタイプはblog } # 新記事のディレクトリ名（ゼロパディング）とフルバス p = pathlib.Path(work_dir) dir_list = [p.name for p in p.iterdir() if p.is_dir()] dir_list.sort() latest_dir = int(dir_list[-1]) fm_dict[\u0026#34;new_dir_name\u0026#34;] = str(latest_dir + 1).zfill(3) fm_dict[\u0026#34;new_dir_path\u0026#34;] = work_dir + fm_dict[\u0026#34;new_dir_name\u0026#34;] # 新記事の作成日時（long: YYYY-MM-DD HH:MM:SS / short: YYYYMMDD） dt = datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) fm_dict[\u0026#34;created_date_long\u0026#34;] = dt fm_dict[\u0026#34;created_date_short\u0026#34;] = (dt[2:10]).replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;) # アイキャッチの画像パス fm_dict[\u0026#34;eye_path\u0026#34;] = f\u0026#39;/ec/blog/ec_blog_{fm_dict[\u0026#34;new_dir_name\u0026#34;]}.jpg\u0026#39; # スラッグ fm_dict[\u0026#34;slug_str\u0026#34;] = f\u0026#39;{fm_dict[\u0026#34;new_dir_name\u0026#34;]}-{fm_dict[\u0026#34;created_date_short\u0026#34;]}-\u0026#39; return fm_dict def generate_blog_file(params: dict): \u0026#34;\u0026#34;\u0026#34; 新記事のディレクトリとファイルを作成する Args: params: フロントマターに設定する情報 \u0026#34;\u0026#34;\u0026#34; dir_name = params[\u0026#34;new_dir_name\u0026#34;] dir_path = params[\u0026#34;new_dir_path\u0026#34;] l_date = params[\u0026#34;created_date_long\u0026#34;] s_date = params[\u0026#34;created_date_short\u0026#34;] img_path = params[\u0026#34;eye_path\u0026#34;] slug = params[\u0026#34;slug_str\u0026#34;] post_type = params[\u0026#34;post_type\u0026#34;] # ディレクトリを作成 pathlib.Path(dir_path + \u0026#34;/img/\u0026#34;).mkdir(parents=True) # mdファイルにテンプレートからフロントマターを設定 md_full_path = f\u0026#34;{dir_path}/{dir_name}_{s_date}.md\u0026#34; with open(\u0026#34;template/front_matter.txt\u0026#34;) as fm: t = string.Template(fm.read()) template = t.substitute(date=l_date, image=img_path, slug=slug, type=post_type) with open(md_full_path, \u0026#34;w\u0026#34;) as new_md: new_md.write(template) # macOSのAutomatorと連携するために引数としてファイルパスを出力 print(md_full_path) if __name__ == \u0026#34;__main__\u0026#34;: config = configparser.ConfigParser() config.read(\u0026#34;config.ini\u0026#34;) blog_path = config[\u0026#34;path\u0026#34;][\u0026#34;blog\u0026#34;] generate_blog_file(create_front_matter_info(blog_path)) ▶︎ 最新版は GitHub\n","date":"2020/03/29","permalink":"/blog/001-blog-writing-tool/","section":"","summary":"Python と Automator の連携方法","title":"Python と Automator でブログ執筆ツールをつくりました"},{"content":"Me\u003e Me 花村貴史 / Takashi Hanamura です。\nソフトウェアエンジニア 空気感フォトグラファー 横浜育ち 38 年、脱サラ → 信州移住 2 年半、2018 年春から関西在住、翌年秋から夫婦生活スタート 関西に来てよかったことは京都が近くなったこと 2010 年から親指シフト使い プライベートでは Golang/Python/C++ 周辺を楽しみ、オシゴトでは SAP に携わっているエンジニアです。週末フォトグラファーでもあります。\n被写体は植物や水といった自然が多く、人を撮らせていただくことも。とくに撮られることに慣れてない方の笑顔や、空気感をすくい撮ることを得意としています。\n詳しいプロフィールは僕のもうひとつのサイト、 PROFILE | Takashi Q. Hanamura Photography に詳しく書いています。\nSite\u003e Site nnamm.work の work は作品のこと 技術的なネタや日々のことを書きためる場所 作品を紹介する Hub となる場所 を静的サイトジェネレーターを使って運営していきます。\nStatic Site Generators\u003e Static Site Generators SSG はこれまで Gridsome、 Pelican と使ってきてました。Pelican では Tailwind CSS を利用したテーマを自作してウキウキしていたのですが、サイトのビルドに時間がかかるのがネック。\nそこで速度重視の Hugo に移行することに。テーマは Blowfish をカスタムしています。実際にビルドは速いです。\nSSG は SPA や WordPress とは違い、静的ファイルが生成されるだけだから非常にシンプルですね。\n","date":"2019/03/22","permalink":"/about/","section":"","summary":"自己紹介とサイトの説明","title":"About"}]