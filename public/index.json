[{"content":"アクセス解析サービス\u003e アクセス解析サービス 当サイトでは、Google の提供するアクセス解析サービス「Google アナリティクス」を使用しています。トラフィックデータを収集するために、Google がお使いのブラウザの Cookie を設定したり、既存の Cookie を読み取ることがあります。このデータは匿名で収集されており、個人を特定するものではございません。\n収集された情報は、当サイトのパフォーマンスやコンテンツを改善する目的に利用する場合がございます。\nGoogle アナリティクスのデータ収集、処理の仕組みについては、「 Google のサービスを使用するサイトやアプリから収集した情報の Google による使用 – ポリシーと規約 – Google」のページを参照下さい。\nこうした Cookie による情報収集を望まない場合は、ユーザ自身がブラウザで Cookie の受け入れを拒否するよう設定することも可能です。一例として「 Google アナリティクス オプトアウト アドオン」がございます。\n著作権\u003e 著作権 nnamm.work における各種コンテンツの著作権は放棄しておりませんが、当サイト記事の引用や、紹介についてはご自由になさっていただいて構いません。シェアは大歓迎です。引用する際は、よかったら Facebook か Twitter からご連絡をいただければ幸いです。\n作成：2021 年 5 月 29\n","date":"2021/05/29","permalink":"/privacy-policy/","section":"","summary":"nnamm.workのプライバシーポリシー","title":"Privacy Policy"},{"content":"","date":"2020/04/29","permalink":"/","section":"","summary":"","title":""},{"content":"","date":"2020/04/29","permalink":"/blog/","section":"","summary":"","title":""},{"content":"","date":"2020/04/29","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"2020/04/29","permalink":"/categories/programming/","section":"Categories","summary":"","title":"Programming"},{"content":"","date":"2020/04/29","permalink":"/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"これまで Python スクリプトを組んできたものの、いずれもユニットテストは未実施。自分仕様ですから「そこまでしなくても」となりがち。でも、実際の現場ではテストは必須。潜在的なバグに気づけますから。\n実は昨今のテストって仕組みがややこしそう（※）・・・と敬遠してましたが、それではいつまで経ってもレベルアップできませんのでユニットテストにチャレンジしました。\n※人生ではじめて単体テストしたのは某鶴のマークの航空会社のアセンブリ言語でした。機械語の細かい挙動を見ながらやっていましたね。それはもう地味で地道な作業でしたが必要なことでした。・・・とこのような経験からいわゆる高級言語のテストがどうやって動いているのかイメージができいないんです。\n※しかし、2023 年 1 月現在は Golang の testing を学んだりして、昨今のテストは昔に比べてなんて楽なんだと感じています。テストコードを書くのは手間ですけどね（笑）\n環境\u003e 環境 Python 3.8.2 テストフレームワーク： unittest テスト対象： md-generator 参考： Python と Automator でブログ執筆ツールをつくりました テストの準備\u003e テストの準備 テストファイルの作成\u003e テストファイルの作成 まずはテストファイルを作ります。「test_ + テスト対象モジュール名.py」とするのが習わしなので、「test_gen_md_generator.py」となります。\nコードはこんな感じになりました。\n# test_gen_md_generator.py \u0026#34;\u0026#34;\u0026#34; md-generator のユニットテストケース \u0026#34;\u0026#34;\u0026#34; import os import unittest import gen_md_file as md TEST_ANS_DICT = { \u0026#34;new_dir_name\u0026#34;: \u0026#34;006\u0026#34;, \u0026#34;new_dir_path\u0026#34;: \u0026#34;/Users/nnamm.work/Develop/MyProject/_test/006\u0026#34;, \u0026#34;created_date_long\u0026#34;: \u0026#34;2020-04-29 15:00:00\u0026#34;, \u0026#34;created_date_short\u0026#34;: \u0026#34;200429\u0026#34;, \u0026#34;eye_path\u0026#34;: \u0026#34;/ec/blog/ec_blog_006.jpg\u0026#34;, \u0026#34;slug_str\u0026#34;: \u0026#34;006-200429-\u0026#34;, \u0026#34;post_type\u0026#34;: \u0026#34;blog\u0026#34;, } TEST_ANS_LIST = [\u0026#34;006_200429.md\u0026#34;, \u0026#34;img\u0026#34;] class GeneratorMdTest(unittest.TestCase): \u0026#34;\u0026#34;\u0026#34; テストクラス \u0026#34;\u0026#34;\u0026#34; def setUp(self) -\u0026gt; None: pass def tearDown(self) -\u0026gt; None: pass def test_create_front_matter_info(self): \u0026#34;\u0026#34;\u0026#34; フロントマター情報の確認 \u0026#34;\u0026#34;\u0026#34; self.assertDictEqual( md.create_front_matter_info(\u0026#34;/Users/nnamm.work/Develop/MyProject/_test/\u0026#34;), TEST_ANS_DICT, ) def test_generate_blog_file(self): \u0026#34;\u0026#34;\u0026#34; ディレクトリとファイル生成の確認 \u0026#34;\u0026#34;\u0026#34; # まずディレクトリとファイルを作成 md.generate_blog_file(TEST_ANS_DICT) # ディレクトリとファイルが正しく作成されているか確認（詳細な中身は目視確認とする） path = \u0026#34;/Users/nnamm/Develop/MyProject/_test/006/\u0026#34; files_list = os.listdir(path) files_list.sort() self.assertListEqual(files_list, TEST_ANS_LIST) テストコードの説明\u003e テストコードの説明 import\n「unittest」と「テスト対象とモジュール」をインポートして、クラスの中に「def test_XXXXXX」でテストケースを作っていきます。\nTEST_ANS_DICT / TEST_ANS_LIST\nassert で評価される値です。テストケースに定数を書いて良いものか標準的なルールを知らないため、そこらへんはご容赦を。\nsetUp() / tearDown()\n各テストの実施前後にさせたい処理を書きます。たとえば print(\u0026quot;Test Start\u0026quot;)、print(\u0026quot;Test End\u0026quot;) としてコンソールログを見やすくしたり、オブジェクトを破棄したりのお掃除系。\ndef test_create_front_matter_info(self)\nFront matter を生成する処理で dict が返ります。テスト用のディレクトリを準備し、想定される結果（TEST_ANS_DICT）と assertDictEqual しています。\ndef test_generate_blog_file(self)\nFront matter を含めた md ファイルを生成する処理です。とくに return されるものはなく、ディレクトリとファイルが生成されます。\n確認ポイント\u003e 確認ポイント さて、ここでは何を確認するべきか？\n想定されたディレクトリ・ファイル構造になったかどうかを評価することにしました。そのために os.listdir() したものを assertListEqual しています。\n実際のファイルは開いて中身を目視確認すればいいでしょう。（下図参照）\nテストの実行\u003e テストの実行 テストコードを PyCharm で走らせてみます。\nEdit Configurations\u003e Edit Configurations Edit Configurations から設定します。\nAdd New Configuration から unittests を選択したら、適当な Name をつけて対象スクリプトを選択して OK します。\nRun\u003e Run うまくいけば「Tests passed」が表示されます。\nassert で想定した結果にならなかった場合、どこが間違っているか表示されるので修整もやりやすかったです。\nやって良かったこと\u003e やって良かったこと 潜在的なバグを見つけたことですね。\n具体的には「create_front_matter_info」で「Python list index out of range」が起こる可能性があります。\nこの関数にはリストから最後の要素を取り出す処理があります。でも、そもそもリストがなければエラーとなります。僕の環境では起こらないので対処しなくてもいいけれど、せっかくなので該当箇所に try 〜 catch をいれました。\n改修した満足感 Get です（笑）\n# gen_md_generator.py（対応前） p = pathlib.Path(work_dir) dir_list = [p.name for p in p.iterdir() if p.is_dir()] dir_list.sort() latest_dir = int(dir_list[-1]) ← ★ここ fm_dict[\u0026#34;new_dir_name\u0026#34;] = str(latest_dir + 1).zfill(3) fm_dict[\u0026#34;new_dir_path\u0026#34;] = work_dir + fm_dict[\u0026#34;new_dir_name\u0026#34;] # gen_md_generator.py（対応後） p = pathlib.Path(work_dir) dir_list = [p.name for p in p.iterdir() if p.is_dir()] dir_list.sort() try: latest_dir = int(dir_list[-1]) fm_dict[\u0026#34;new_dir_name\u0026#34;] = str(latest_dir + 1).zfill(3) fm_dict[\u0026#34;new_dir_path\u0026#34;] = work_dir + fm_dict[\u0026#34;new_dir_name\u0026#34;] except IndexError as err: print(f\u0026#34;作成できません。対象ディレクトリを確認してください。：{err}\u0026#34;) 不明点\u003e 不明点 datetime で now() を使って現在日時を取得している値の正確性を得るためには、テストケースとしてどうすれば良いかわかりませんでした。普通であれば絶対にイコールになることはないですから。\nしゃーないので、テストのときだけテスト対象のモジュールに任意の日時を指定するロジックを加えて回避しました。\n# gen_md_generator.py # 新記事の作成日時（long: YYYY-MM-DD HH:MM:SS / short: YYMMDD） dt = datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) # dt = datetime.datetime(2020, 4, 29, 15).strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) # unittest用に日時指定 ↑★ここ、テスト時だけコメントアウトする ※おそらく unittest.mock を使うのかも。今回は調査していませんので次の課題です。\nおわりに\u003e おわりに 初歩の初歩とはいえユニットテストをやり切りました！\n今回得たことは「テストしやすいコードはどうすれば組めるか？」という視点ですね。複雑な処理を重ねてやることもあるでしょうけど、ややこしい処理は分解してシンプルに組めばテストしやすくなるはず。\nテストしやすいということは、コード品質を上げやすいということ。\nだからといって、やたらと分解していいものでもないと思いますので、その塩梅は開発を経験し、センスが磨かれていくことで掴めていくものでしょう。センスはやればやるほど自然と磨かれているものだからね。\nユニットテスト、いい経験と気づきになりました。\n※掲載した写真は大阪城公園を RICOH GR で撮影\n","date":"2020/04/29","permalink":"/blog/003-python-first-unittest/","section":"","summary":"unittest を使った感想","title":"Python｜はじめての unittest、使い方を整理してみる"},{"content":"","date":"2020/04/29","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2020/04/05","permalink":"/tags/macos/","section":"Tags","summary":"","title":"macOS"},{"content":"静的サイトジェネレーターは静的ファイルを生成します。WordPress とは異なり、記事公開まで数ステップ必要です。\n記事を書く ビルドして全サイトデータを生成（※） レンタルサーバーにすべてのファイルをアップロード だから、GitHub pages を使っている方もいらっしゃると思います。git push とともにデプロイされるのは楽ですからね。 Vercel を使うのもありでしょう。\nでも、僕はすでに持っている独自ドメインや WordPress で使っているレンタルサーバーがあるのでこれらを流用したい。\nそこで公開までさくっとやってくれるスクリプトを組みました。Pyftpsync を使い、 前回と同じく Automator を使ってアプリケーション化しています。\nPyftpsync とは\u003e Pyftpsync とは Martin Wendt さんがつくられている Python ライブラリで「ローカルとリモートを rsync 風にやってくれるもの」と僕は理解しています。\n▶︎ Pyftpsync\nただし、既知の制限があります。最たるものは 2 つ。\n差分検知はファイルサイズと変更日から判断している ローカルフォルダ内に個別のメタデータファイルをつくり、最後の同期時刻とサイズを保存することで差分を検出する つまり Gridsome ではこうなります。\nstatic 配下の画像ファイルなど同一同名でも「差分あり」となる ビルドすると dist 配下のすべてのファイルが全削除＆再生成されるため、上記 2 の効果がない 結果、ほとんどのファイルがアップロード対象となる 当初の僕の希望である「rsync コマンドのように差分だけがアップロードされればデプロイも短時間で済むじゃん」は達成できません。\nでもメリットもちゃんとあります。手動でアップロードするよりだんぜん楽ということです。\n2023 年 1 月現在、SSG を Gridsome から Pelican に、さらに Hugo に移行しました。Gridsome の記述がありますが、Hugo で使っていません。本記事では Pyftpsync の使い方の紹介なので当日の記事のままとします。\nPyftpsync の使い方\u003e Pyftpsync の使い方 公式のとおりに作ればとてもカンタン。使いやすい設計です。以下は同期モードの例で、他にアップロードモードがあります。\nfrom ftpsync.ftp_target import FtpTarget from ftpsync.targets import FsTarget from ftpsync.synchronizers import BiDirSynchronizer local = FsTarget(\u0026#34;ローカルディレクトリパス\u0026#34;) remote = FtpTarget( \u0026#34;リモートディレクトリパス\u0026#34;, \u0026#34;FTPサーバーアドレス\u0026#34;, username=\u0026#34;FTPアカウント\u0026#34;, password=\u0026#34;FTPパスワード\u0026#34;, tls=True # Trueの場合、FTPSが有効 ) # オプション設定例 opts = { \u0026#34;resolve\u0026#34;: \u0026#34;local\u0026#34; # コンフリクトした場合はローカルファイルを優先 } # 同期の実行 sync = BiDirSynchronizer(local, remote, opts) sync.run() ※デフォルトではコンソールにログ出力されますので何やっているかが分かります。\nおわりに\u003e おわりに WordPress や note を使ってきて「公開までの仕組みがすべてつくられていること」ってすごいことだなと痛感しています。で、ここにきて SSG を使ったサイト運営ですよ。\n「手間かかることを楽しんでいる」感があります（笑）\nでも、その結果\n楽するためにどうするか？ 効率化するためできることはあるか？ という視点が磨かれてきましたし、なければつくってしまえ、という思考＆行動パターンになってきました。エンジニアに復帰した僕としては、これはとても望ましい成長と思っています。\nひとつひとつ作っていく感覚は楽しいです。\n最近はコロナのせいで自宅に籠る時間ができました。だからこそ、思いっきり勉強したり、思いっきり怠惰をむさぼったり、これまでの生活スタイルを進化させられるんじゃないか、と僕は思います。\nたとえば、当たり前と言われているものの反対をやってみて、人間としての幅を広げられたらいいんじゃないかな。\n「より良い未来のために、今できることをする」です。\n参考：sync_gridsome.py\u003e 参考：sync_gridsome.py \u0026#34;\u0026#34;\u0026#34; pyftpsyncライブラリを同期モードで使用し、Gridsomeでビルドしたデータ（dist/）をデプロイ先と同期する \u0026#34;\u0026#34;\u0026#34; import configparser import logging.handlers from ftpsync.ftp_target import FtpTarget from ftpsync.targets import FsTarget from ftpsync.synchronizers import BiDirSynchronizer from ftpsync.util import set_pyftpsync_logger def sync_gridsome() -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; 指定のローカルとリモートディレクトリを同期する \u0026#34;\u0026#34;\u0026#34; cfg = configparser.ConfigParser() cfg.read(\u0026#34;config.ini\u0026#34;) # ローカルとリモートの設定 local = FsTarget(cfg[\u0026#34;PATH\u0026#34;][\u0026#34;LOCAL\u0026#34;]) user = cfg[\u0026#34;FTPS\u0026#34;][\u0026#34;USER\u0026#34;] passwd = cfg[\u0026#34;FTPS\u0026#34;][\u0026#34;PASSWORD\u0026#34;] remote = FtpTarget( cfg[\u0026#34;PATH\u0026#34;][\u0026#34;REMOTE\u0026#34;], # リモートディレクトリパス cfg[\u0026#34;FTPS\u0026#34;][\u0026#34;SERVER\u0026#34;], # FTPサーバ username=user, password=passwd, tls=True, # FTPS有効 ) # オプション設定 # ローカル優先／--deleteオプション有効／指定ディレクトリは同期除外 # opts = {\u0026#34;resolve\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;delete\u0026#34;: True, \u0026#34;force\u0026#34;: True} opts = {\u0026#34;resolve\u0026#34;: \u0026#34;local\u0026#34;} # 同期の実行 sync = BiDirSynchronizer(local, remote, opts) sync.run() if __name__ == \u0026#34;__main__\u0026#34;: # ロガーの設定 # pyftpsync.logにログを残す logger = logging.getLogger(\u0026#34;sync.gridsome\u0026#34;) log_path = \u0026#34;./pyftpsync.log\u0026#34; handler = logging.handlers.WatchedFileHandler(log_path) formatter = logging.Formatter( \u0026#34;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#34; ) handler.setFormatter(formatter) logger.addHandler(handler) set_pyftpsync_logger(logger) # 同期 sync_gridsome() ▶ 最新版は GitHub\n","date":"2020/04/05","permalink":"/blog/002-python-ftp-sync/","section":"","summary":"Pyftpsync の使用方法","title":"Python｜Pyftpsync を使ってローカルとリモートを同期する"},{"content":"","date":"2020/03/29","permalink":"/categories/creative/","section":"Categories","summary":"","title":"Creative"},{"content":"静的サイトジェネレーター（SSG）で作ったサイトの記事は Markdown ファイルで管理します。\nWordPress でいう Title、Date、Description、Category、tags などの設定もできて、ファイルの冒頭に Front matter と呼ばれるデータを書きこむことで、SSG がよしなに判断してあれこれしてくれます。\nただ、記事を書くたびに\nファイルを作成 Front matter（定型文）をコピペ タイトルや日付などを入力 するのは手間がかかるので macOS の Automator を使ってツールを 2 つ作りました。\nMarkdown ファイルを作り、任意のエディタを起動するアプリ gridsome develop を起動し、指定のブラウザで localhost に接続するショートカットキー この記事では Python や Automator との連携方法をまとめます。\n2021 年 6 月現在、SSG を Gridsome から Pelican に変更しました。Front matter の中身も変わったため、掲載している内容やスクリプトが現在とは若干異なっています。でも、本筋は変わっていませんので参考になるかと思います。\n1. Markdown ファイルを作り、任意のエディタを起動するアプリ\u003e 1. Markdown ファイルを作り、任意のエディタを起動するアプリ Python で Markdown ファイルを作る\u003e Python で Markdown ファイルを作る 僕のサイトでは以下のように記事ファイルと画像ファイルを配置しています。\n/static/posts/blog/ | |__001/ | |__img/ | |__001_200322.md | |__002 | |__img/ | |__002_YYMMDD.md | （以降、003、004と記事ごとに増えていく） 「ディレクトリ名が 1 つずつ加算されている」部分やファイル名の「YYMMDD」などがプログラミングの使い所。\nディレクトリやファイル操作をすればいいので Pathlib モジュールを使います。パスをオブジェクトとして操作できるようになります。\n参考： pathlib \u0026mdash; オブジェクト指向のファイルシステムパス\n次は Front matter です。\nこれは以下のようなデータ群になってます。「$」ではじまっている変数はスクリプトを実行するたびに設定します。これを毎回コピペするのはすっごく面倒なのでここでもプログラミングの力を使いましょう。\n--- title: date: $date createdAt: $date updatedAt: $date description: image: $image slug: $slug category: tags: type: $type --- 「$」は定型文や動的にテキストデータを設定するところなので、String モジュールのtemplateを使います。\n参考： string \u0026mdash; 一般的な文字列操作\n使い方はかんたんで、Front matter の定義ファイルを開いて、substitute()で$変数に値を入れる。それを Markdown ファイルにwrite()で OK です。\n# gen_md_file.py（一部抜粋） import string md_full_path = f\u0026#34;{dir_path}/{dir_name}_{s_date}.md\u0026#34; with open(\u0026#34;template/front_matter.txt\u0026#34;) as fm: t = string.Template(fm.read()) template = t.substitute(date=l_date, image=img_path, slug=slug, type=post_type) with open(md_full_path, \u0026#34;w\u0026#34;) as new_md: new_md.write(template) Automator からスクリプトを実行してエディタを起動する\u003e Automator からスクリプトを実行してエディタを起動する 新しく記事を書くたびに python コマンドを叩くのは手間です。それにどうせなら Markdown ファイルを開いてすぐブログを書きはじめられたら素敵じゃないですか。\nそんなときは Automator にシェルコマンドを入力してもらいましょう。\nAutomator を起動して「アプリケーション」を選択。\nAutomator で Python を実行するには、シェルから実行してもらうようにしないといけません。以下の順番でつなげていきます。\nシェルスクリプトを実行 指定された Finder 項目を取得 Finder 項目を開く（お好きなアプリを選択） シェル実行時に Markdown ファイルの絶対パスをprint()で出力しています。それが「指定された Finder 項目を取得」につながって、次の「Finder 項目を開く」へとつながっていきます。\nさらに、どうせなら Automator で作ったアプリのアイコンも変えましょう。\nまず、Automator で作たアプリの情報ウィンドウを表示させます。次に左上のアイコンを選択状態にしてから、あらかじめクリップボードにコピーしておいた画像を command+v してあげれば OK です。\n2. gridsome develop を起動し、指定のブラウザで localhost に接続するショートカットキー\u003e 2. gridsome develop を起動し、指定のブラウザで localhost に接続するショートカットキー 記事を書きながらプレビューできたら便利ですよね。今回はショートカットキーで起動するようにします。\nAutomator を起動して「クイックアクション」を選択。\n以下の順でつなげていきます。\n指定された Finder 項目を取得（後述のコマンドファイルを指定） Finder 項目を開く 一時停止（ビルドにちょっと時間がかかるため一休み） シェルスクリプトを実行（ブラウザのフルパス + URL） コマンドファイル\u003e コマンドファイル 「シェルスクリプトを実行」から直接gridsome developをすると、ctrl+c で Gridsome のプロセスを停止できません。僕から見えない誰かがプロセスを握ってしまっているためだと思います。\nなので、以下のコマンドファイルを作り、Terminal を起動してから実行してあげる必要があります。\n$ touch _start_gridsome.command $ vim _start_gridsome.command cd ~/Develop/MyProject/gridsome_nnamm/ gridsome develop 実行権限をつけるのを忘れずに。\n$ chmod a+x _start_gridsome.command ショートカットキーの設定\u003e ショートカットキーの設定 クイックアクションは macOS のサービスとして扱われるため、システム環境設定から任意のショートカットキーを割り当ててあげましょう。\nこれで完成です。\nおわりに\u003e おわりに アプリアイコンをダブルクリックするだけでブログが書けるようになりました。必要に応じてショートカットキーでプレビュー画面を起動するということもできました。\n大満足！\n参考：gen_md_file.py\u003e 参考：gen_md_file.py \u0026#34;\u0026#34;\u0026#34; 新規ブログ記事の雛形Markdownファイルを作るスクリプト 所定のディレクトリに、以下のディレクトリを作成する ...blog/ |__001 |_img/ |_001_YYMMDD.md（フロントマター含） \u0026#34;\u0026#34;\u0026#34; import configparser import datetime import pathlib import string def create_front_matter_info(work_dir: str) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34; フロントマター用のデータを作成する Args: work_dir: 所定のディレクトリパス Returns: dict: フロントマターに設定する情報 \u0026#34;\u0026#34;\u0026#34; fm_dict = { \u0026#34;new_dir_name\u0026#34;: \u0026#34;\u0026#34;, # 新記事を格納するディレクトリ名（作業用） \u0026#34;new_dir_path\u0026#34;: \u0026#34;\u0026#34;, # 上記を含めたフルパス \u0026#34;created_date_long\u0026#34;: \u0026#34;\u0026#34;, # 記事作成日時ロング版（スクリプト実行日時） \u0026#34;created_date_short\u0026#34;: \u0026#34;\u0026#34;, # 上記のショート版 \u0026#34;eye_path\u0026#34;: \u0026#34;\u0026#34;, # アイキャッチの画像のパス \u0026#34;slug_str\u0026#34;: \u0026#34;\u0026#34;, # スラッグ \u0026#34;post_type\u0026#34;: \u0026#34;blog\u0026#34;, # ポストタイプはblog } # 新記事のディレクトリ名（ゼロパディング）とフルバス p = pathlib.Path(work_dir) dir_list = [p.name for p in p.iterdir() if p.is_dir()] dir_list.sort() latest_dir = int(dir_list[-1]) fm_dict[\u0026#34;new_dir_name\u0026#34;] = str(latest_dir + 1).zfill(3) fm_dict[\u0026#34;new_dir_path\u0026#34;] = work_dir + fm_dict[\u0026#34;new_dir_name\u0026#34;] # 新記事の作成日時（long: YYYY-MM-DD HH:MM:SS / short: YYYYMMDD） dt = datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) fm_dict[\u0026#34;created_date_long\u0026#34;] = dt fm_dict[\u0026#34;created_date_short\u0026#34;] = (dt[2:10]).replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;) # アイキャッチの画像パス fm_dict[\u0026#34;eye_path\u0026#34;] = f\u0026#39;/ec/blog/ec_blog_{fm_dict[\u0026#34;new_dir_name\u0026#34;]}.jpg\u0026#39; # スラッグ fm_dict[\u0026#34;slug_str\u0026#34;] = f\u0026#39;{fm_dict[\u0026#34;new_dir_name\u0026#34;]}-{fm_dict[\u0026#34;created_date_short\u0026#34;]}-\u0026#39; return fm_dict def generate_blog_file(params: dict): \u0026#34;\u0026#34;\u0026#34; 新記事のディレクトリとファイルを作成する Args: params: フロントマターに設定する情報 \u0026#34;\u0026#34;\u0026#34; dir_name = params[\u0026#34;new_dir_name\u0026#34;] dir_path = params[\u0026#34;new_dir_path\u0026#34;] l_date = params[\u0026#34;created_date_long\u0026#34;] s_date = params[\u0026#34;created_date_short\u0026#34;] img_path = params[\u0026#34;eye_path\u0026#34;] slug = params[\u0026#34;slug_str\u0026#34;] post_type = params[\u0026#34;post_type\u0026#34;] # ディレクトリを作成 pathlib.Path(dir_path + \u0026#34;/img/\u0026#34;).mkdir(parents=True) # mdファイルにテンプレートからフロントマターを設定 md_full_path = f\u0026#34;{dir_path}/{dir_name}_{s_date}.md\u0026#34; with open(\u0026#34;template/front_matter.txt\u0026#34;) as fm: t = string.Template(fm.read()) template = t.substitute(date=l_date, image=img_path, slug=slug, type=post_type) with open(md_full_path, \u0026#34;w\u0026#34;) as new_md: new_md.write(template) # macOSのAutomatorと連携するために引数としてファイルパスを出力 print(md_full_path) if __name__ == \u0026#34;__main__\u0026#34;: config = configparser.ConfigParser() config.read(\u0026#34;config.ini\u0026#34;) blog_path = config[\u0026#34;path\u0026#34;][\u0026#34;blog\u0026#34;] generate_blog_file(create_front_matter_info(blog_path)) ▶︎ 最新版は GitHub\n","date":"2020/03/29","permalink":"/blog/001-blog-writing-tool/","section":"","summary":"Python と Automator の連携方法","title":"Python と Automator でブログ執筆ツールをつくりました"},{"content":"Me\u003e Me 花村貴史 / Takashi Hanamura です。\nソフトウェアエンジニア 空気感フォトグラファー 横浜育ち 38 年、脱サラ → 信州移住 2 年半、2018 年春から関西在住、翌年秋から夫婦生活スタート 関西に来てよかったことは京都が近くなったこと 2010 年から親指シフト使い プライベートでは Golang/Python/C++ 周辺を楽しみ、オシゴトでは SAP に携わっているエンジニアです。週末フォトグラファーでもあります。\n被写体は植物や水といった自然が多く、人を撮らせていただくことも。とくに撮られることに慣れてない方の笑顔や、空気感をすくい撮ることを得意としています。\n詳しいプロフィールは僕のもうひとつのサイト、 PROFILE | Takashi Q. Hanamura Photography に詳しく書いています。\nSite\u003e Site nnamm.work の work は作品のこと 技術的なネタや日々のことを書きためる場所 作品を紹介する Hub となる場所 を静的サイトジェネレーターを使って運営していきます。\nStatic Site Generators\u003e Static Site Generators SSG はこれまで Gridsome、 Pelican と使ってきてました。Pelican では Tailwind CSS を利用したテーマを自作してウキウキしていたのですが、サイトのビルドに時間がかかるのがネック。\nそこで速度重視の Hugo に移行することに。テーマは Blowfish をカスタムしています。実際にビルドは速いです。\nSSG は SPA や WordPress とは違い、静的ファイルが生成されるだけだから非常にシンプルですね。\n","date":"2019/03/22","permalink":"/about/","section":"","summary":"自己紹介とサイトの説明","title":"About"}]